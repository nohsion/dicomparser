<!DOCTYPE HTML>
<html lang="en">

<head>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <style>
        #dropZone {
            height: 500px;
            width: 100%;
            background-color: #F0F0F0;
            overflow: auto;
        }
    </style>

</head>

<body>
    <div class="container">

        <div class="page-header">
            <h1>DICOM Beam Table</h1>
            <p class="lead">
                Drag and drop a DICOM Part 10 file into the light gray region below for a dump of its elements.
            </p>
            <p>
                This example illustrates how to recursively iterate over a parsed data set to dump all data elements
                into a tree like structure. Note that DICOM files dropped here are not uploaded anywhere, all processing
                is done inside your web browser in Javascript.
            </p>
            <strong>Use of this example require IE10+ or any other modern browser.</strong>
        </div>


        <div id="status" class="alert alert-success">
            <div id="statusText">
                Status: Ready (no file loaded)
            </div>
            <ul id="warnings">

            </ul>
        </div>

        <div class="row">
            <div class="col-md-12">
                <div id="dropZone">

                    <div class="text-center" style="margin-top:225px;">
                        <h3>Drag DICOM P10 file here to dump its elements</h3>
                    </div>

                </div>
            </div>
        </div>

    </div>
</body>

<!-- include the dicomParser library -->
<script src="../node_modules/dicom-parser/dist/dicomParser.js"></script>
<script>window.dicomParser || document.write('<script src="https://unpkg.com/dicom-parser">\x3C/script>')</script>

<!-- jquery - included to make things easier to demo, not needed by dicomParser -->
<script src="https://code.jquery.com/jquery-3.4.1.js"></script>

<script>

    // helper function to see if a string only has ascii characters in it
    function isASCII(str) {
        return /^[\x00-\x7F]*$/.test(str);
    }

    // This function iterates through dataSet recursively and adds new HTML strings
    // to the output array passed into it
    function dumpDataSet(dataSet, output) {
        let usingTags = {
            'x300a00c0': 'Beam Number',
            'x300a00c6': 'Radiation Type', // PHOTON, NEUTRON, ELECTRON, PROTON
            'x300a00ce': 'Treatment Delivery Type',
            'x300a0084': 'Beam Dose',
            'x300a00c2': 'Beam Name',
            'x300a00b2': 'Machine Name',
            'x300a00c4': 'Beam Type', // DYNAMIC, STATIC
            'x00185100': 'Position',
            'x300a0114': 'Energy',
            'x300a0115': 'Dose Rate (MU/min)',
            'x300a0086': 'M/U',
            'x300a0130': 'SSD (cm)',
            'x300a011e': 'Gantry Angle', // first + last item
            'x300a011f': 'Gantry Rotation Direction', // CW, CC, NONE
            'x300a0120': 'Colli Angle', // first item
            'x300a011c': 'Leaf/Jaw Positions',
            'x300a00b8': 'Collimator Type', // X,Y,ASYMX,ASYMY,MLCX,MLCY
            'x300a00d5': 'Wedge Angle',
            'x300a00d5': 'Wedge ID',
            'x300a0118': 'Wedge Position', 
            'x300a0108': 'Electron Applicator ID',
            'x300a0112': 'Couch Rtn (degree)',
            'x300a00c6': 'Radiation Type'
        }

        try {

            for (var propertyName in dataSet.elements) {

                var element = dataSet.elements[propertyName];
                let text = ''

                let energyUnit = ''

                if (element.items) {
                    // console.log(element)
                    // output.push('<li>' + text + '</li>');
                    output.push('<ul>');

                    let itemNumber = 0;
                    element.items.forEach(function (item) {
                        // output.push('<li>Item #' + itemNumber++ + ' ' + '</li>')
                        dumpDataSet(item.dataSet, output);
                    });
                    output.push('</ul>');
                }
                else {

                    if (element.length < 128 && Object.keys(usingTags).includes(element.tag)) {


                        text += (usingTags[element.tag] + ' -')
                        var str = dataSet.string(propertyName);

                        /*
                            Additional Parsing processing
                        */
                        // SSD 단위 변환
                        if (element.tag === 'x300a0130') {
                            str = Math.round(Number(str) * 10) / 10
                        }
                        // MU 단위 변환
                        if (element.tag === 'x300a0086') {
                            str = Math.round(Number(str) * 10) / 10
                        }


                        var stringIsAscii = isASCII(str);

                        if (stringIsAscii) {
                            if (str !== undefined) {
                                text += ' "' + str + '" ';
                            }
                        }

                    }
                    if (text) {
                        output.push('<li>' + text + '</li>')
                    }
                }

            }
        } catch (err) {
            var ex = {
                exception: err,
                output: output
            }
            throw ex;
        }
    }

    // This function will read the file into memory and then start dumping it
    function dumpFile(file) {
        // clear any data currently being displayed as we parse this next file
        document.getElementById('dropZone').innerHTML = '';
        $('#status').removeClass('alert-warning alert-success alert-danger').addClass('alert-info');
        $('#warnings').empty();
        document.getElementById('statusText').innerHTML = 'Status: Loading file, please wait..';

        var reader = new FileReader();
        reader.onload = function (file) {
            var arrayBuffer = reader.result;
            // Here we have the file data as an ArrayBuffer.  dicomParser requires as input a
            // Uint8Array so we create that here
            var byteArray = new Uint8Array(arrayBuffer);
            var kb = byteArray.length / 1024;
            var mb = kb / 1024;
            var byteStr = mb > 1 ? mb.toFixed(3) + " MB" : kb.toFixed(0) + " KB";
            document.getElementById('statusText').innerHTML = 'Status: Parsing ' + byteStr + ' bytes, please wait..';
            // set a short timeout to do the parse so the DOM has time to update itself with the above message
            setTimeout(function () {

                // Invoke the paresDicom function and get back a DataSet object with the contents
                var dataSet;
                try {
                    var start = new Date().getTime();
                    dataSet = dicomParser.parseDicom(byteArray);
                    // Here we call dumpDataSet to recursively iterate through the DataSet and create an array
                    // of strings of the contents.
                    var output = [];
                    dumpDataSet(dataSet, output);

                    // Combine the array of strings into one string and add it to the DOM
                    document.getElementById('dropZone').innerHTML = '<ul>' + output.join('') + '</ul>';

                    var end = new Date().getTime();
                    var time = end - start;
                    if (dataSet.warnings.length > 0) {
                        $('#status').removeClass('alert-success alert-info alert-danger').addClass('alert-warning');
                        $('#statusText').html('Status: Warnings encountered while parsing file (file of size ' + byteStr + ' parsed in ' + time + 'ms)');

                        dataSet.warnings.forEach(function (warning) {
                            $("#warnings").append('<li>' + warning + '</li>');
                        });
                    }
                    else {
                        var pixelData = dataSet.elements.x7fe00010;
                        if (pixelData) {
                            $('#status').removeClass('alert-warning alert-info alert-danger').addClass('alert-success');
                            $('#statusText').html('Status: Ready (file of size ' + byteStr + ' parsed in ' + time + 'ms)');
                        }
                        else {
                            $('#status').removeClass('alert-warning alert-info alert-danger').addClass('alert-success');
                            $('#statusText').html('Status: Ready - no pixel data found (file of size ' + byteStr + ' parsed in ' + time + 'ms)');
                        }
                    }


                }
                catch (err) {
                    var message = err;
                    if (err.exception) {
                        message = err.exception;
                    }

                    $('#status').removeClass('alert-success alert-info alert-warning').addClass('alert-danger');
                    document.getElementById('statusText').innerHTML = 'Status: Error - ' + message + ' (file of size ' + byteStr + ' )';
                    if (err.output) {
                        document.getElementById('dropZone').innerHTML = '<ul>' + output.join('') + '</ul>';
                    }
                    else if (err.dataSet) {
                        var output = [];
                        dumpDataSet(err.dataSet, output);
                        document.getElementById('dropZone').innerHTML = '<ul>' + output.join('') + '</ul>';
                    }
                }
            }, 10);
        };

        reader.readAsArrayBuffer(file);
    }


    // this function gets called once the user drops the file onto the div
    function handleFileSelect(evt) {
        evt.stopPropagation();
        evt.preventDefault();

        // Get the FileList object that contains the list of files that were dropped
        var files = evt.dataTransfer.files;

        // this UI is only built for a single file so just dump the first one
        dumpFile(files[0]);
    }

    function handleDragOver(evt) {
        evt.stopPropagation();
        evt.preventDefault();
        evt.dataTransfer.dropEffect = 'copy'; // Explicitly show this is a copy.
    }

    // Setup the dnd listeners.
    var dropZone = document.getElementById('dropZone');
    dropZone.addEventListener('dragover', handleDragOver, false);
    dropZone.addEventListener('drop', handleFileSelect, false);


</script>

</html>