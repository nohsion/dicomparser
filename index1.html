<!DOCTYPE HTML>
<html lang="en">

<head>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <style>
        #dropZone {
            height: 500px;
            width: 100%;
            background-color: #F0F0F0;
            overflow: auto;
        }
    </style>

</head>

<body>
    <div class="container">

        <div class="page-header">
            <h1>DICOM Beam Table</h1>
            <p class="lead">
                Drag and drop a DICOM Part 10 file into the light gray region below for a dump of its elements.
            </p>
            <p>
                This example illustrates how to recursively iterate over a parsed data set to dump all data elements
                into a tree like structure. Note that DICOM files dropped here are not uploaded anywhere, all processing
                is done inside your web browser in Javascript.
            </p>
            <strong>Use of this example require IE10+ or any other modern browser.</strong>
        </div>


        <div id="status" class="alert alert-success">
            <div id="statusText">
                Status: Ready (no file loaded)
            </div>
            <ul id="warnings">

            </ul>
        </div>

        <div class="row">
            <div class="col-md-12">
                <div id="dropZone">

                    <div class="text-center" style="margin-top:225px;">
                        <h3>Drag DICOM P10 file here to dump its elements</h3>
                    </div>

                </div>
            </div>
        </div>

    </div>
</body>

<!-- include the dicomParser library -->
<script src="../node_modules/dicom-parser/dist/dicomParser.js"></script>
<script>window.dicomParser || document.write('<script src="https://unpkg.com/dicom-parser">\x3C/script>')</script>

<!-- jquery - included to make things easier to demo, not needed by dicomParser -->
<script src="https://code.jquery.com/jquery-3.4.1.js"></script>

<script>
    class DefaultDict {
        constructor(defaultInit) {
            return new Proxy({}, {
                get: (target, name) => name in target ?
                    target[name] :
                    (target[name] = typeof defaultInit === 'function' ?
                        new defaultInit().valueOf() :
                        defaultInit)
            })
        }
    }
    // helper function to see if a string only has ascii characters in it
    function isASCII(str) {
        return /^[\x00-\x7F]*$/.test(str);
    }

    function itemLength(dataSet) {
        let itemLength;
        for (let propertyName in dataSet.elements) {

            let element = dataSet.elements[propertyName];

            if (element.tag === 'x300a00b0') {
                itemLength = element.items.length
            }
        }
        return itemLength
    }

    // This function iterates through dataSet recursively and adds new HTML strings
    // to the output array passed into it
    const lists = new DefaultDict(Array)

    function dumpDataSet(dataSet, output, itemLen) {

        let usingTags = {
            'x300a00b0': 'Beam SQ',
            'x300a00c0': 'Beam Number',
            'x300a00c6': 'Radiation Type', // PHOTON, NEUTRON, ELECTRON, PROTON
            'x300a00ce': 'Treatment Delivery Type',
            'x300a0084': 'Beam Dose',
            'x300a00c2': 'Beam Name',
            'x300a00b2': 'Machine Name',
            'x300a00c4': 'Beam Type', // DYNAMIC, STATIC
            'x00185100': 'Position',
            'x300a0114': 'Energy',
            'x300a0115': 'Dose Rate (MU/min)',
            'x300a0086': 'M/U',
            'x300a0130': 'SSD (cm)',
            'x300a011e': 'Gantry Angle', // first + last item
            'x300a011f': 'Gantry Rotation Direction', // CW, CC, NONE
            'x300a0120': 'Colli Angle', // first item
            'x300a011c': 'Leaf/Jaw Positions',
            'x300a00b8': 'Collimator Type', // X,Y,ASYMX,ASYMY,MLCX,MLCY
            'x300a00d5': 'Wedge Angle',
            'x300a00d5': 'Wedge ID',
            'x300a0118': 'Wedge Position',
            'x300a0108': 'Electron Applicator ID',
            'x300a0122': 'Patient Support Angle',
            'x300a00c6': 'Radiation Type',
            'x300a0110': 'Number of Control Points',
            'x300a00ed': 'Number of Boli',
            'x300a01d2': 'Table Top Longitudinal Setup Displacement',
            'x300a01d4': 'Table Top Vertical Setup Displacement',
            'x300a01d6': 'Table Top Lateral Setup Displacement',
            'x300a00e0': 'Number of Compensators',
            'x300a00ec': 'Compensator Thickness',
            'x300c0004': 'Referenced Beam Sequence'
        }

        try {

            for (var propertyName in dataSet.elements) {

                var element = dataSet.elements[propertyName];
                let text = ''

                // Beam Dose가 있는지 확인
                // if (element.tag === 'x300c0004') {
                //     element.items.forEach(function (item) {
                //         console.log(item.dataSet.elements)
                //         for (let tag in item.dataSet.elements) {
                //             if (tag === 'x300a0084') {
                                
                //             }
                //         }
                //     })
                // }

                if (element.items) {
                    
                    itemNumber = 0;
                    element.items.forEach(function (item) {
                        // console.log(itemNumber)
                        itemNumber++
                        dumpDataSet(item.dataSet, output, itemLen);
                    });
                }
                else {

                    if (element.length < 128 && Object.keys(usingTags).includes(element.tag)) {

                        let str = dataSet.string(propertyName);

                        /*
                            Additional Parsing processing
                        */
                        // SSD, MU 단위 변환
                        if (element.tag === 'x300a0130' || element.tag === 'x300a0086') {
                            str = Math.round(Number(str) * 10) / 10
                        }

                        let stringIsAscii = isASCII(str);

                        if (stringIsAscii) {
                            if (str !== undefined) {
                                text = str
                            }
                        }

                    }
                    if (text) {
                        // let tmp = []
                        // tmp.push(itemNumber)
                        // tmp.push(text)
                        // lists[usingTags[element.tag]].push(tmp)

                        lists[usingTags[element.tag]].push(text)

                        // console.log('#', itemNumber, text)
                    }
                }

            }
        } catch (err) {
            var ex = {
                exception: err,
                output: lists
            }
            console.log(err)
            throw ex;
        }
    }

    function download(content, fileName, contentType) {
        var a = document.createElement("a");
        var file = new Blob([content], { type: contentType });
        a.href = URL.createObjectURL(file);
        a.download = fileName;
        a.click();
    }

    // This function will read the file into memory and then start dumping it
    function dumpFile(file) {
        // clear any data currently being displayed as we parse this next file
        document.getElementById('dropZone').innerHTML = '';
        $('#status').removeClass('alert-warning alert-success alert-danger').addClass('alert-info');
        $('#warnings').empty();
        document.getElementById('statusText').innerHTML = 'Status: Loading file, please wait..';

        var reader = new FileReader();
        reader.onload = function (file) {
            var arrayBuffer = reader.result;
            // Here we have the file data as an ArrayBuffer.  dicomParser requires as input a
            // Uint8Array so we create that here
            var byteArray = new Uint8Array(arrayBuffer);
            var kb = byteArray.length / 1024;
            var mb = kb / 1024;
            var byteStr = mb > 1 ? mb.toFixed(3) + " MB" : kb.toFixed(0) + " KB";
            document.getElementById('statusText').innerHTML = 'Status: Parsing ' + byteStr + ' bytes, please wait..';
            // set a short timeout to do the parse so the DOM has time to update itself with the above message
            setTimeout(function () {

                // Invoke the paresDicom function and get back a DataSet object with the contents
                var dataSet;
                try {
                    var start = new Date().getTime();
                    dataSet = dicomParser.parseDicom(byteArray);
                    // Here we call dumpDataSet to recursively iterate through the DataSet and create an array
                    // of strings of the contents.

                    const itemLen = itemLength(dataSet)
                    var output = new DefaultDict(Array)
                    dumpDataSet(dataSet, output, itemLen);

                    console.log(lists)
                    const json = JSON.stringify(lists);
                    // console.log(json);
                    // download(json, 'parsed_json.txt', 'text/plain');

                    // Combine the array of strings into one string and add it to the DOM
                    // document.getElementById('dropZone').innerHTML = '<ul>' + output.join('') + '</ul>';

                    // var end = new Date().getTime();
                    // var time = end - start;
                    // if (dataSet.warnings.length > 0) {
                    //     $('#status').removeClass('alert-success alert-info alert-danger').addClass('alert-warning');
                    //     $('#statusText').html('Status: Warnings encountered while parsing file (file of size ' + byteStr + ' parsed in ' + time + 'ms)');

                    //     dataSet.warnings.forEach(function (warning) {
                    //         $("#warnings").append('<li>' + warning + '</li>');
                    //     });
                    // }
                    // else {
                    //     var pixelData = dataSet.elements.x7fe00010;
                    //     if (pixelData) {
                    //         $('#status').removeClass('alert-warning alert-info alert-danger').addClass('alert-success');
                    //         $('#statusText').html('Status: Ready (file of size ' + byteStr + ' parsed in ' + time + 'ms)');
                    //     }
                    //     else {
                    //         $('#status').removeClass('alert-warning alert-info alert-danger').addClass('alert-success');
                    //         $('#statusText').html('Status: Ready - no pixel data found (file of size ' + byteStr + ' parsed in ' + time + 'ms)');
                    //     }
                    // }


                }
                catch (err) {
                    console.log(err)
                    // var message = err;
                    // if (err.exception) {
                    //     message = err.exception;
                    // }

                    // $('#status').removeClass('alert-success alert-info alert-warning').addClass('alert-danger');
                    // document.getElementById('statusText').innerHTML = 'Status: Error - ' + message + ' (file of size ' + byteStr + ' )';
                    // if (err.output) {
                    //     document.getElementById('dropZone').innerHTML = '<ul>' + output.join('') + '</ul>';
                    // }
                    // else if (err.dataSet) {
                    //     var output = [];
                    //     dumpDataSet(err.dataSet, output);
                    //     document.getElementById('dropZone').innerHTML = '<ul>' + output.join('') + '</ul>';
                    // }
                }
            }, 10);
        };

        reader.readAsArrayBuffer(file);
    }


    // this function gets called once the user drops the file onto the div
    function handleFileSelect(evt) {
        evt.stopPropagation();
        evt.preventDefault();

        // Get the FileList object that contains the list of files that were dropped
        var files = evt.dataTransfer.files;

        // this UI is only built for a single file so just dump the first one
        dumpFile(files[0]);
    }

    function handleDragOver(evt) {
        evt.stopPropagation();
        evt.preventDefault();
        evt.dataTransfer.dropEffect = 'copy'; // Explicitly show this is a copy.
    }

    // Setup the dnd listeners.
    var dropZone = document.getElementById('dropZone');
    dropZone.addEventListener('dragover', handleDragOver, false);
    dropZone.addEventListener('drop', handleFileSelect, false);


</script>

</html>