<!DOCTYPE HTML>
<html lang="en">

<head>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <style>
        #dropZone {
            height: 500px;
            width: 100%;
            background-color: #F0F0F0;
            overflow: auto;
        }
    </style>

</head>

<body>
    <div class="container">

        <div class="page-header">
            <h1>DICOM Beam Table</h1>
            <p class="lead">
                Drag and drop a DICOM Part 10 file into the light gray region below for a dump of its elements.
            </p>
            <p>
                This example illustrates how to recursively iterate over a parsed data set to dump all data elements
                into a tree like structure. Note that DICOM files dropped here are not uploaded anywhere, all processing
                is done inside your web browser in Javascript.
            </p>
            <strong>Use of this example require IE10+ or any other modern browser.</strong>
        </div>


        <div id="status" class="alert alert-success">
            <div id="statusText">
                Status: Ready (no file loaded)
            </div>
            <ul id="warnings">

            </ul>
        </div>

        <div class="row">
            <div class="col-md-12">
                <div id="dropZone">

                    <div class="text-center" style="margin-top:225px;">
                        <h3>Drag DICOM P10 file here to dump its elements</h3>
                    </div>

                </div>
            </div>
        </div>

    </div>
</body>

<!-- include the dicomParser library -->
<script src="../node_modules/dicom-parser/dist/dicomParser.js"></script>
<script>window.dicomParser || document.write('<script src="https://unpkg.com/dicom-parser">\x3C/script>')</script>

<!-- jquery - included to make things easier to demo, not needed by dicomParser -->
<script src="https://code.jquery.com/jquery-3.4.1.js"></script>

<script>
    class DefaultDict {
        constructor(defaultInit) {
            return new Proxy({}, {
                get: (target, name) => name in target ?
                    target[name] :
                    (target[name] = typeof defaultInit === 'function' ?
                        new defaultInit().valueOf() :
                        defaultInit)
            })
        }
    }
    // helper function to see if a string only has ascii characters in it
    function isASCII(str) {
        return /^[\x00-\x7F]*$/.test(str);
    }

    function itemLength(dataSet) {
        let itemLength;
        for (let propertyName in dataSet.elements) {

            let element = dataSet.elements[propertyName];

            if (element.tag === 'x300a00b0') {
                itemLength = element.items.length
            }
        }
        return itemLength
    }

    // This function iterates through dataSet recursively and adds new HTML strings
    // to the output array passed into it
    const lists = new DefaultDict(Array)
    let jsonData = {}
    let itemNumber = -100
    let depth = 0

    function dumpDataSet(dataSet, output, itemLen) {
        let usingTags = {
            'x300a00b0': 'Beam SQ',
            'x300a00c0': 'Beam Number',
            'x300a00c6': 'Radiation Type', // PHOTON, NEUTRON, ELECTRON, PROTON
            'x300a00ce': 'Treatment Delivery Type',
            'x300a0084': 'Beam Dose',
            'x300a00c2': 'Beam Name',
            'x300a00b2': 'Machine Name',
            'x300a00c4': 'Beam Type', // DYNAMIC, STATIC
            'x00185100': 'Position',
            'x300a0114': 'Energy',
            'x300a0115': 'Dose Rate (MU/min)',
            'x300a0086': 'M/U',
            'x300a0130': 'SSD (cm)',
            'x300a011e': 'Gantry Angle', // first + last item
            'x300a011f': 'Gantry Rotation Direction', // CW, CC, NONE
            'x300a0120': 'Colli Angle', // first item
            'x300a011c': 'Leaf/Jaw Positions',
            'x300a00b8': 'Collimator Type', // X,Y,ASYMX,ASYMY,MLCX,MLCY
            'x300a00d5': 'Wedge Angle',
            'x300a00d5': 'Wedge ID',
            'x300a0118': 'Wedge Position',
            'x300a0108': 'Electron Applicator ID',
            'x300a0122': 'Patient Support Angle',
            'x300a00c6': 'Radiation Type',
            'x300a0110': 'Number of Control Points',
            'x300a00ed': 'Number of Boli',
            'x300a01d2': 'Table Top Longitudinal Setup Displacement',
            'x300a01d4': 'Table Top Vertical Setup Displacement',
            'x300a01d6': 'Table Top Lateral Setup Displacement',
            'x300a00e0': 'Number of Compensators',
            'x300a00ec': 'Compensator Thickness',
            'x300c0004': 'Referenced Beam Sequence'
        }

        try {

            for (var propertyName in dataSet.elements) {

                var element = dataSet.elements[propertyName];
                let text = ''

                if (element.items) {
                    depth++
                    element.items.forEach(function (item, index) {
                        itemNumber = index
                        console.log('item #', itemNumber, item.tag)

                        dumpDataSet(item.dataSet, output, itemLen);
                        itemNumber = index
                        // console.log('item #', itemNumber, index, item.tag)
                    });
                    depth--
                }
                else {
                    if (element.length < 128 && Object.keys(usingTags).includes(element.tag)) {

                        let str = dataSet.string(propertyName);

                        /*
                            Additional Parsing processing
                        */
                        // SSD, MU 단위 변환
                        if (element.tag === 'x300a0130' || element.tag === 'x300a0086') {
                            str = Math.round(Number(str) * 10) / 10
                        }

                        let stringIsAscii = isASCII(str);

                        if (stringIsAscii) {
                            if (str !== undefined) {
                                text = str
                            }
                        }

                    }
                    if (text) {
                        let tmp = []
                        tmp.push(itemNumber)
                        tmp.push(text)
                        lists[usingTags[element.tag]].push(tmp)
                        console.log('depth:', depth, 'item #', itemNumber, element.tag, usingTags[element.tag], text)
                        // lists[usingTags[element.tag]].push(text)

                        // console.log('#', itemNumber, text)
                    }
                }

            }
        } catch (err) {
            var ex = {
                exception: err,
                output: lists
            }
            console.log(err)
            throw ex;
        }
    }

    function download(content, fileName, contentType) {
        var a = document.createElement("a");
        var file = new Blob([content], { type: contentType });
        a.href = URL.createObjectURL(file);
        a.download = fileName;
        a.click();
    }

    // This function will read the file into memory and then start dumping it
    function dumpFile(file) {
        // clear any data currently being displayed as we parse this next file
        document.getElementById('dropZone').innerHTML = '';
        $('#status').removeClass('alert-warning alert-success alert-danger').addClass('alert-info');
        $('#warnings').empty();
        document.getElementById('statusText').innerHTML = 'Status: Loading file, please wait..';

        var reader = new FileReader();
        reader.onload = function (file) {
            var arrayBuffer = reader.result;
            // Here we have the file data as an ArrayBuffer.  dicomParser requires as input a
            // Uint8Array so we create that here
            var byteArray = new Uint8Array(arrayBuffer);
            var kb = byteArray.length / 1024;
            var mb = kb / 1024;
            var byteStr = mb > 1 ? mb.toFixed(3) + " MB" : kb.toFixed(0) + " KB";
            document.getElementById('statusText').innerHTML = 'Status: Parsing ' + byteStr + ' bytes, please wait..';
            // set a short timeout to do the parse so the DOM has time to update itself with the above message
            setTimeout(function () {

                // Invoke the paresDicom function and get back a DataSet object with the contents
                var dataSet;
                try {
                    var start = new Date().getTime();
                    dataSet = dicomParser.parseDicom(byteArray);
                    // Here we call dumpDataSet to recursively iterate through the DataSet and create an array
                    // of strings of the contents.

                    console.log(dataSet)
                    const itemLen = itemLength(dataSet)
                    var output = new DefaultDict(Array)
                    dumpDataSet(dataSet, output, itemLen);

                    console.log(lists)

                    jsonData = JSON.stringify(lists, null, 2);

                    // console.log(jsonData);
                    // download(jsonData, 'parse.json', 'text/plain');


                }
                catch (err) {
                    console.log(err)
                }
            }, 10);
        };

        reader.readAsArrayBuffer(file);
    }


    // this function gets called once the user drops the file onto the div
    function handleFileSelect(evt) {
        evt.stopPropagation();
        evt.preventDefault();

        // Get the FileList object that contains the list of files that were dropped
        var files = evt.dataTransfer.files;

        // this UI is only built for a single file so just dump the first one
        dumpFile(files[0]);
    }

    function handleDragOver(evt) {
        evt.stopPropagation();
        evt.preventDefault();
        evt.dataTransfer.dropEffect = 'copy'; // Explicitly show this is a copy.
    }

    // Setup the dnd listeners.
    var dropZone = document.getElementById('dropZone');
    dropZone.addEventListener('dragover', handleDragOver, false);
    dropZone.addEventListener('drop', handleFileSelect, false);


</script>

</html>